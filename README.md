# 2048Solver

This program uses Selenium WebDriver API to interact with the 2048 puzzle online -- not only to simulate arrow keys to actually play the game, but also to access online local storage the 2048 puzzle uses to store the game state after each move. This allows the algorithm to know the state of each tile after each move to best decide where to go next. 

The brain of the program is the directory "nextMove", which contains various algorithms, ranging from naive to machine-learning, to analyze the current board state and determine where to go next. "simulator2048" is the body of the program, which chooses which algorithm from "nextMove" to import, starts up the browser to the 2048 puzzle and repeatedly reads in the game state, calls the chosen algorithm, and implements the move decided by the algorithm until the program either wins or loses.  

smartGridClass is a helper class I wrote to ease the process of writing decision algorithms. Essentially, the game state of 2048 is a 4x4 grid that contains the values at each position. Rather than simply use an array to store the game state, I use a smartGridClass object. This is because the class contains four methods that simulate (without the new random tile that appears after each turn) a move in each of the four directions. Thus, an algorithm can simply call the method to simulate a move in a given direction and evaluate it instead of worrying about simulating the move itself. For example, if it contains a game state "A" and wishes to determine whether it should move "up", it simply needs to call the A.simulateMove("up") to see what the future game state would look like and whether or not it "likes" it. 

On top of smartGridClass is nodeClass. Several of the decision algorithms I wrote don't simply use a given game state to determine a single move. Through experimentation, I have found that the algorithms are more successful when they use a game state to determine several consecutive moves simultaneously (e.g. 5) that "simulator2048" then executes as sequence before calling the algorithm again with an updated game state. nodeClass helps to ease the process of an algorithm attempting to determine the best set of consecutive moves by acting as a node with a smartGridClass object as value. Thus, a set of given game states and the corresponding moves to get to each following state can be represented by a linked list that only needs to be  traversed to obtain the final sequence of moves to execute. 
